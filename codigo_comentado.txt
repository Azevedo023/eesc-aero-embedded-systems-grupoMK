#include <cmath>  // Biblioteca para funções matemáticas como pow, sqrt, etc.
#include <iostream>  // Para entrada e saída de dados
#include <iomanip>  // Para manipular a formatação da saída
#include <fstream>  // Para manipular arquivos
#include <algorithm>  // Para usar funções como std::for_each e outras operações algorítmicas
#include "ManoplaLelyBBB.h"  // Arquivo de cabeçalho específico do projeto (possivelmente para interação com hardware)
#include <armadillo>  // Biblioteca para álgebra linear (operações com matrizes e vetores)
#include <tuple>  // Para criar e usar tuplas (agrupamento de múltiplos valores)
#include <vector>  // Biblioteca para trabalhar com vetores (arrays dinâmicos)
#include <string>  // Manipulação de strings
#include <sstream>  // Para construir e manipular strings como streams de dados
#include <chrono>  // Para manipular tempo e medições de alta precisão

using Clock = std::chrono::high_resolution_clock;  // Alias para facilitar o uso do clock de alta precisão

// Função que simula um evento com base em k, a e b
double event(double k, double a = 16, double b = 0.01) {
    return a * std::pow((1 - b), k);  // Cálculo do evento usando uma fórmula exponencial
}

// Função que calcula um super-evento usando normas e o resultado da função 'event'
double super_event(double x_norm, double matrix_norm, double k, double a = 30, double b = 0.001, double sigma = 0.01) {
    return sigma * x_norm / matrix_norm + event(k, a, b);  // Combinação de valores normalizados com o evento
}

// Definição de constantes para o argumento da interface CAN e de versões/sync
constexpr unsigned int ARG_CAN_INTERFACE = 1;
constexpr unsigned int ARG_VERSION = 1;
constexpr unsigned int ARG_SYNCCALLBACK = 2;  // Modo de operação (posição, corrente, PID, etc.)

constexpr unsigned int ARG_SYNCCALLBACK_PID_KP = 3;  // Constante Kp para o PID
constexpr unsigned int ARG_SYNCCALLBACK_PID_KD = 4;  // Constante Kd para o PID
constexpr unsigned int ARG_SYNCCALLBACK_PID_KI = 5;  // Constante Ki para o PID

constexpr unsigned int ARG_SYNCCALLBACK_DLQR_TYPE = 3;  // Tipo de controle DLQR
constexpr unsigned int ARG_SYNCCALLBACK_DLQREVENT_TYPE = 3;  // Tipo de evento DLQR
constexpr unsigned int ARG_SYNCCALLBACK_DLQREVENT_EVENTPRESET = 4;  // Tipo de preset de evento

// Definição de valores padrão para constantes do PID
constexpr float DEFAULT_KP = 1800.f;
constexpr float DEFAULT_KD = 150.f;
constexpr float DEFAULT_KI = 0.f;

// Enumeração para definir tipos de referência: Constante ou Senoidal
enum class ReferenceType {
    ConstantZero,
    SineWave,
};

// Definições de strings para tipos de referência
#define CONSTANTZERO "constant-zero"
#define SINEWAVE "sine-wave"

// Sobrecarga do operador << para exibir o tipo de referência como string
std::ostream& operator<<(std::ostream& o, ReferenceType rt) {
    if (rt == ReferenceType::ConstantZero) {
        o << CONSTANTZERO;  // Se for do tipo Constante, exibe a string correspondente
    } else if (rt == ReferenceType::SineWave) {
        o << SINEWAVE;  // Se for do tipo Senoidal, exibe a string correspondente
    }
    return o;
}

// Mapeamento de strings para tipos de referência usando std::map
std::map<std::string, ReferenceType> ReferenceTypeString {
    { CONSTANTZERO, ReferenceType::ConstantZero },
    { SINEWAVE, ReferenceType::SineWave },
};

// Tipo de referência padrão definido como Constante
const ReferenceType DEFAULT_REFERENCETYPE = ReferenceType::ConstantZero;

// Comentado: Definição de matrizes do sistema (anterior)
// arma::mat sys_matrix_A = {{ 2.82975412e-15 , 1.00000000e+00 },
//                           {-9.80269531e-01 , 1.97873008e+00 }};
// arma::colvec sys_matrix_B = { 1.84982170e-15 , 6.72172757e-03 };
// arma::rowvec sys_dlqr_K = { 15.12857803, -16.25584753 };
// double matrix_norm{0.1492657117991687};

// Definição de novas matrizes para o sistema (consideradas melhores)
arma::mat sys_matrix_A = {{ 9.98609061e-01, 1.09025360e+01 },
                          { -1.13123668e-04, 9.77691957e-01 }};
arma::colvec sys_matrix_B = { 8.6104e-3, 8.0799e-4 };
arma::rowvec sys_dlqr_K = { -2.70079861, -233.77001218 };

// Estrutura que define presets para controle DLQR com parâmetros de evento e tipo de referência
struct EventDLQRControlPreset {
    arma::rowvec K;
    double a;
    double b;
    double sigma;
    ReferenceType ct;  // Tipo de referência usado no controle
};

// Enumeração para diferentes presets de controle
enum class ControllerPreset {
    DR6,    // Controle constante com valores específicos
    EDR24,  // Controle constante com parâmetros a, b e sigma definidos
    EDR83,  // Outro controle constante com parâmetros diferentes
    DC6,    // Controle senoidal com outros parâmetros
    EDC56,  // Controle senoidal com diferentes parâmetros a, b e sigma
    EDC103, // Outro controle senoidal com parâmetros modificados
};

// Sobrecarga do operador << para exibir o preset do controlador como string
std::ostream& operator<<(std::ostream& o, ControllerPreset cp) {
    switch (cp) {
        case ControllerPreset::DR6:
            o << "DR6"; break;
        case ControllerPreset::EDR24:
            o << "EDR24"; break;
        case ControllerPreset::EDR83:
            o << "EDR83"; break;
        case ControllerPreset::DC6:
            o << "DC6"; break;
        case ControllerPreset::EDC56:
            o << "EDC56"; break;
        case ControllerPreset::EDC103:
            o << "EDC103"; break;
    }
    return o;
}

// Mapeamento de strings para presets de controladores usando std::map
std::map<std::string, ControllerPreset> ControllerPresetString{
    { "DR6", ControllerPreset::DR6 },
    { "EDR24", ControllerPreset::EDR24 },
    { "EDR83", ControllerPreset::EDR83 },
    { "DC6", ControllerPreset::DC6 },
    { "EDC56", ControllerPreset::EDC56 },
    { "EDC103", ControllerPreset::EDC103 }
};

// Mapeamento de presets de controladores para parâmetros de controle DLQR (K, a, b, sigma, tipo de referência)
std::map<ControllerPreset, EventDLQRControlPreset> DLQRControlPresets{
    { ControllerPreset::DR6,     EventDLQRControlPreset{ .K={-89.9178, -1155.41}, .a=0, .b=0, .sigma=0, .ct=ReferenceType::ConstantZero }},
    { ControllerPreset::EDR24,   EventDLQRControlPreset{ .K={-1.90978, -194.491}, .a=16, .b=1e-3, .sigma=0.01, .ct=ReferenceType::ConstantZero }},
    { ControllerPreset::EDR83,   EventDLQRControlPreset{ .K={-21.6764, -644.052}, .a=10, .b=.2, .sigma=0.01, .ct=ReferenceType::ConstantZero }},
    { ControllerPreset::DC6,     EventDLQRControlPreset{ .K={-89.9178, -1155.41}, .a=0, .b=0, .sigma=0, .ct=ReferenceType::SineWave }},
    { ControllerPreset::EDC56,   EventDLQRControlPreset{ .K={-2.7008, -233.77 }, .a=30, .b=1e-3, .sigma=0.01, .ct=ReferenceType::SineWave }},
    { ControllerPreset::EDC103,  EventDLQRControlPreset{ .K={-50.5014, -924 }, .a=10, .b=.2, .sigma=0.01, .ct=ReferenceType::SineWave }}
};

// Variável booleana para verificar se o preset do controlador foi selecionado
bool controllerPresetSelected{false};

// Variável para armazenar a norma da matriz
double matrix_norm{};





/*
 * tuple DataPoint:
 *   uint64_t time_us,              // Armazena o tempo em microssegundos (64 bits sem sinal).
 *   int32_t pulse_qc,              // Pulso de quadratura (32 bits com sinal), relacionado à contagem de pulsos do encoder.
 *   double setpoint_current_mA,    // Ponto de ajuste da corrente desejada em miliampères (tipo double).
 *   int16_t actual_current_mA,     // Corrente medida real em miliampères (16 bits com sinal).
 *   int32_t epos_velocity_unfiltered_rpm, // Velocidade não filtrada do motor (32 bits com sinal) em RPM.
 *   float calculated_velocity_rad/s,// Velocidade calculada em rad/s (tipo float).
 *   float tracked_reference,       // Referência monitorada (tipo float).
 *   float event_max_error,         // Erro máximo durante o evento (tipo float).
 *   float event_error              // Erro do evento (tipo float).
*/

using DataPoint = std::tuple<uint64_t /*time_us*/,    // Define o tipo 'DataPoint' como uma tupla com 9 elementos.
                             int32_t /*pulse_qc*/,    // O segundo elemento é o pulso de quadratura (int32_t).
                             double /*setpoint_current_mA*/, // O terceiro elemento é o setpoint da corrente.
                             int16_t /*actual_current_mA*/,  // O quarto é a corrente medida.
                             int32_t /*epos_velocity_unfiltered_rpm*/, // O quinto é a velocidade do motor.
                             float /*calculated_velocity_rad/s*/,     // O sexto é a velocidade calculada.
                             float /*tracked_reference*/,  // O sétimo é a referência monitorada.
                             float /*event_max_error*/,    // O oitavo é o erro máximo do evento.
                             float /*event_error*/>;       // O nono é o erro do evento.


class MyLog {
    std::vector<DataPoint> log;      // Vetor que armazena os pontos de dados (DataPoint).
    std::vector<std::string> logHeader; // Vetor de strings que contém os cabeçalhos da tabela de log.
public: // A parte pública da classe inclui o construtor e os métodos.
    explicit MyLog(const std::vector<std::string>& logHeader): log(), logHeader(logHeader){ // Construtor que inicializa 'log' vazio e atribui 'logHeader' passado como argumento.
    }

    void addDataPoint(const DataPoint & dp) { // Adiciona um ponto de dados (dp) ao vetor 'log'.
        log.push_back(dp); // Insere o ponto de dados no vetor 'log'.
    }

    void saveToFile(const std::string& fileName, // Método para salvar os dados de log em um arquivo.
                    const std::string& controllerType,  // Tipo de controlador usado.
                    const ReferenceType& rt,            // Tipo de referência.
                    arma::mat A,                        // Matriz A.
                    arma::mat B,                        // Matriz B.
                    arma::mat K,                        // Matriz K.
                    double a,                           // Parâmetro 'a' do evento.
                    double b,                           // Parâmetro 'b' do evento.
                    double sigma,                       // Parâmetro 'sigma' do evento.
                    float refresh_rate){                // Taxa de atualização.

        using std::setw;      // Define o espaçamento para a saída formatada.
        using std::setfill;   // Define o caractere de preenchimento (usado para zeros).

        std::stringstream ssFileName;  // Declara um stringstream para construir o nome do arquivo.
        auto now = Clock::to_time_t(Clock::now()); // Obtém o tempo atual.
        auto localtime = std::localtime(&now);    // Converte para o horário local.

        ssFileName << "log_" << localtime->tm_year + 1900   // Ano atual.
           << "-" << setfill('0') << setw(2) << localtime->tm_mon+1 // Mês com dois dígitos.
           << "-" << setfill('0') << setw(2) << localtime->tm_mday  // Dia.
           << "_" << setfill('0') << setw(2) << localtime->tm_hour  // Hora.
           << "-" << setfill('0') << setw(2) << localtime->tm_min   // Minuto.
           << "-" << setfill('0') << setw(2) << localtime->tm_sec   // Segundo.
           << "_" << fileName;  // Acrescenta o nome fornecido ao final.

        std::ofstream file{ssFileName.str()};  // Abre o arquivo para gravação.

        file.precision(10); // Define a precisão das saídas numéricas para 10 dígitos.

        file << "[Configuration]\n"  // Inicia a seção de configuração no arquivo.
                << "controller_type = " << controllerType << "\n"  // Escreve o tipo de controlador.
                << "reference_type = "  << rt << "\n"  // Escreve o tipo de referência.

                // Escreve as matrizes A, B e K, formatadas cientificamente:
                << "A = [ [ " << std::scientific << A[0,0] << "  ,  " << std::scientific << A[0,1] << " ] , [ " << std::scientific << A[1,0] << "  ,  " << std::scientific << A[1,1] << " ] ] \n"
                << "B = [ [ " << std::scientific << B[0]   << "] , [" << std::scientific << B[1] << " ]]\n"
                << "K = [ [ " << std::scientific << K[0]   << "  ,  " << std::scientific << K[1] << " ]]\n"

                << "event_a = "     << std::scientific << a     << "\n"  // Escreve o valor de 'a'.
                << "event_b = "     << std::scientific << b     << "\n"  // Escreve o valor de 'b'.
                << "event_sigma = " << std::scientific << sigma << "\n"  // Escreve o valor de 'sigma'.

                << "refresh_rate = " << std::scientific << refresh_rate << "\n"  // Escreve a taxa de atualização.
                << "\n"  // Nova linha.
                << "[Table]\n";  // Inicia a seção da tabela.

        std::for_each(logHeader.cbegin(), logHeader.cend()-1, [&](const auto &item) { // Itera sobre os cabeçalhos, exceto o último.
            file << item << ',';  // Escreve cada cabeçalho seguido por uma vírgula.
        });

        file << (logHeader.cend()-1)->data() << '\n';  // Escreve o último cabeçalho seguido de uma nova linha.

        for(const auto& dp : log) {  // Para cada ponto de dados no log.
            file << setw(20) << std::get<0>(dp) << ','   // Escreve o tempo (primeiro valor da tupla).
                 << setw(20) << std::get<1>(dp) << ','   // Escreve o pulso.
                 << setw(20) << std::get<2>(dp) << ','   // Escreve o setpoint da corrente.
                 << setw(20) << std::get<3>(dp) << ','   // Escreve a corrente medida.
                 << setw(20) << std::get<4>(dp) << ','   // Escreve a velocidade do motor.
                 << setw(20) << std::get<5>(dp) << ','   // Escreve a velocidade calculada.
                 << setw(20) << std::get<6>(dp) << ','   // Escreve a referência monitorada.
                 << setw(20) << std::get<7>(dp) << ','   // Escreve o erro máximo do evento.
                 << setw(20) << std::get<8>(dp) << '\n'; // Escreve o erro do evento.
        }
    }
};  // Fim da classe MyLog.

int main(int argc, char* argv[]) {
    // Função principal do programa. Recebe o número de argumentos (argc) e os argumentos passados na linha de comando (argv[]).

    std::cout << "Hello, World!" << std::endl;
    // Imprime "Hello, World!" no console.

    std::string can_interface_name{};
    std::string synccallback{};
    float kp{0}, ki{0}, kd{0};
    ReferenceType referenceType{};
    std::string controllerArgParameter;
    // Declaração de variáveis de tipo string e float para armazenar dados do sistema, como nome da interface CAN, tipo de callback de sincronização, e valores de parâmetros de controle PID.

    double event_a{30};
    double event_b{0.001};
    double event_sigma{0.01};
    // Inicializa os parâmetros event_a, event_b e event_sigma com valores padrão para controle de eventos.

    std::string version{};
    std::stringstream usage_message;
    // Declara variáveis para armazenar a versão do programa e a mensagem de uso.

    usage_message << "Usage:\n"
                  << argv[0] << "<canbus-interface-name> <canopen-syncsallback> [reference-type]\n"
                     "  canopen-synccallback: position-mode, current-mode, pid, dlqr, dlqr-event\n"
                     "    position-mode: no arguments\n"
                     "    current-mode: no arguments\n"
                     "    pid:\n"
                     "      no arguments (default: kp=1800, kd=150, ki=0), or\n"
                     "      kp kd ki\n"
                     "    dlqr [controller-type]\n"
                     "      reference-types:\n"
                     "        no arguments (default: constant-zero), or\n"
                     "        constant-zero\n"
                     "        senoidal\n"
                     "        DR6\n"
                     "        DC6\n"
                     "    dlqr-event [controller-type]\n"
                     "      reference-types:\n"
                     "        no arguments (default: constant-zero), or\n"
                     "        constant-zero\n"
                     "        senoidal\n"
                     "        EDR24\n"
                     "        EDR83\n"
                     "        EDC56\n"
                     "        EDC103\n"
                     "\n"
                     "\n"
                     "ADVANCED: DON'T MESS WITH THIS IF YOU DON'T KNOW WHAT YOU ARE DOING!\n"
                     "environment variable:"
                     "    SYS_DLQR_K: defines the gain matrix for the dLQR controller\n"
                     "      default (and stable):\n"
                     "      SYS_DLQR_K=-2.70079861 -233.77001218\n"
                     "    EVENT_A_B_SIGMA: defines the a, b and sigma parameters for triggering the event\n"
                     "                     setting this will override the controller parameters!\n"
                     "      (menor metrica_comparacao - default\n"
                     "         EVNET_A_B_SIGMA=10 0.2 0.01\n"
                     "      (menor update_rate)\n"
                     "         EVNET_A_B_SIGMA=16 0.001 0.01\n"
                     "\n";
    // Define a mensagem de ajuda do programa, incluindo a sintaxe de uso, tipos de callback permitidos e variáveis de ambiente avançadas para controle do sistema.

    if (argc >= 3) {
        can_interface_name = argv[ARG_CAN_INTERFACE];
        std::cout << "CAN interface choosed: " << can_interface_name << std::endl;
        // Se houver pelo menos três argumentos, define o nome da interface CAN e imprime no console.

        synccallback = argv[ARG_SYNCCALLBACK];
        std::cout << "SyncCallback choosed: " << synccallback << std::endl;
        // Define o tipo de callback de sincronização com base nos argumentos passados e imprime no console.

        if(synccallback == "pid") {
            if (argc < 5 && argc > 3) {
                std::cout << "You must give:\n"
                          << "\t- OR exactly 3 numbers (gains P, D and I) as argument to callback pid choosed!\n"
                          << "\t- OR no arguments to use default values for the gains (P:1800, D:150, I:0)\n";
                std::exit(1);
                // Se o callback for "pid", verifica se os argumentos corretos foram passados (gains P, D e I). Se não, imprime uma mensagem de erro e sai do programa.
            }

            if (argc >= 5) {
                kp = std::stof(argv[ARG_SYNCCALLBACK_PID_KP]);
                kd = std::stof(argv[ARG_SYNCCALLBACK_PID_KD]);
                ki = std::stof(argv[ARG_SYNCCALLBACK_PID_KI]);
                // Converte os argumentos para floats e os armazena nas variáveis kp, kd e ki.

                if (argc > 5) {
                    std::cout << "\nWarning: remaining arguments will not be used!\n";
                    // Se houver mais de 5 argumentos, exibe um aviso de que os argumentos adicionais não serão usados.
                }
            }
            else if (argc == 3){
                std::cout << "Using default values for gains P, D and I!\n";
                kp = DEFAULT_KP;
                kd = DEFAULT_KD;
                ki = DEFAULT_KI;
                // Se não forem fornecidos valores de ganho, usa os valores padrão.
            }

            std::cout << "Gain P: " << kp << "\n"
                      << "Gain D: " << kd << "\n"
                      << "Gain I: " << ki << "\n";
            // Imprime os valores dos ganhos P, D e I no console.
        } else if(synccallback == "dlqr" || synccallback == "dlqr-event") {
            if (argc == 3){
                referenceType = DEFAULT_REFERENCETYPE;
                // Define o tipo de referência padrão se nenhum argumento adicional for passado.
            } else if (argc >=4) {
                controllerArgParameter = std::string{argv[ARG_SYNCCALLBACK_DLQREVENT_TYPE]};
                if (ReferenceTypeString.find(controllerArgParameter) != ReferenceTypeString.end()) {
                    referenceType = ReferenceTypeString[controllerArgParameter];
                } else {
                    controllerPresetSelected = true;
                    // Se o callback for "dlqr" ou "dlqr-event", verifica o tipo de controle ou preset selecionado.
                    // Erros são tratados caso um tipo de controle inválido seja passado, resultando na saída do programa.

                    controllerPresetSelected = true;
                    // Define que um preset de controlador foi selecionado.

                    if (synccallback == "dlqr") {
                        if (ControllerPresetString.find(controllerArgParameter) != ControllerPresetString.end()) {
                            if (controllerArgParameter != "DR6" &&
                                controllerArgParameter != "DC6")
                            {
                                std::cout << "ERROR: synccallback " << controllerArgParameter
                                          << " can only be used with DR6 or DC6!\n"
                                          << controllerArgParameter << " is not allowed!\n\n"
                                          << "EXITING!\n\n";
                                std::exit(1);
                                // Verifica se o controlador selecionado é válido para "dlqr" (DR6 ou DC6). 
                                // Se não for, imprime um erro e sai do programa.
                            }
                        } else {
                            std::cout << "ERROR: synccallback " << controllerArgParameter
                                      << " can only be used with DR6 or DC6!\n"
                                      << controllerArgParameter << " is non-existent!\n\n"
                                      << "EXITING!\n\n";
                            std::exit(1);
                            // Verifica se o preset do controlador existe no mapeamento de strings.
                            // Se não, imprime um erro e encerra o programa.
                        }
                    } else if (synccallback == "dlqr-event") {
                        if (ControllerPresetString.find(controllerArgParameter) != ControllerPresetString.end()) {
                            if (controllerArgParameter != "EDR24" &&
                                controllerArgParameter != "EDR83" &&
                                controllerArgParameter != "EDC56" &&
                                controllerArgParameter != "EDC103")
                            {
                                std::cout << "ERROR: synccallback " << controllerArgParameter
                                          << " can only be used with EDR24, EDR83, EDC56 or EDC103!\n"
                                          << controllerArgParameter << " is not allowed!\n\n"
                                          << "EXITING!\n\n";
                                std::exit(1);
                                // Verifica se os presets de controladores para "dlqr-event" são válidos (EDR24, EDR83, EDC56 ou EDC103).
                                // Caso contrário, exibe um erro e sai do programa.
                            }
                        } else {
                            std::cout << "ERROR: synccallback " << controllerArgParameter
                                      << " can only be used with EDR24, EDR83, EDC56 or EDC103!\n"
                                      << controllerArgParameter << " is non-existent!\n\n"
                                      << "EXITING!\n\n";
                            std::exit(1);
                            // Verifica se o preset do controlador para "dlqr-event" existe no mapeamento de strings.
                            // Caso não exista, imprime uma mensagem de erro e encerra o programa.
                        }
                    }
                }
            }
        } else {
            std::cout << "ERROR: CAN'T CONTINUE!\n"
                        << "SYNCCALLBACK " << synccallback << " DOESN'T EXIST!\n"
                        << "\n"
                        << "It must be one of:\n"
                        << "position-mode, current-mode, pid, dlqr or dlqr-event\n"
                        << "\n";
            std::exit(1);
            // Se o synccallback não for um dos modos válidos (position-mode, current-mode, pid, dlqr, dlqr-event),
            // imprime um erro e encerra o programa.
        }
    } else {
        if(argc == 2) {
            version = argv[ARG_VERSION];
            // Verifica se há dois argumentos (comando e flag de versão).

            if (version == "--version" || version == "-v") {
                std::cout << "Build number: " << "nada" << "\n";
                std::exit(0);
                // Se o argumento for "--version" ou "-v", imprime o número de versão e encerra o programa.
            }
            else {
                std::cout << usage_message.str();
                std::exit(1);
                // Caso contrário, imprime a mensagem de uso e encerra o programa.
            }
        }
        std::cout << usage_message.str();
        std::exit(1);
        // Se não houver argumentos suficientes, imprime a mensagem de uso e encerra o programa.
    }

    if (controllerPresetSelected) {
        event_a = DLQRControlPresets[ControllerPresetString[controllerArgParameter]].a;
        event_b = DLQRControlPresets[ControllerPresetString[controllerArgParameter]].b;
        sys_dlqr_K = DLQRControlPresets[ControllerPresetString[controllerArgParameter]].K;
        event_sigma = DLQRControlPresets[ControllerPresetString[controllerArgParameter]].sigma;
        referenceType = DLQRControlPresets[ControllerPresetString[controllerArgParameter]].ct;
        // Se um preset de controlador foi selecionado, define os valores de event_a, event_b, event_sigma e sys_dlqr_K
        // com base no preset do controlador escolhido.
    }

    std::stringstream ss;
    // Cria uma stringstream para manipulação de strings.

    if(const char* env_a_b_sigma = std::getenv("EVENT_A_B_SIGMA")) {
        std::cout << "OVERRIDING A, B and SIGMA with values from environment variable EVENT_A_B_SIGMA\n"
                    << "Original values:\n"
                    << "a       = " << event_a << "\n"
                    << "b       = " << event_b << "\n"
                    << "sigma   = " << event_sigma << "\n\n";
        ss = std::stringstream{env_a_b_sigma};
        ss >> event_a;
        ss >> event_b;
        ss >> event_sigma;
        std::cout << "NEW values:\n"
                    << "a       = " << event_a << "\n"
                    << "b       = " << event_b << "\n"
                    << "sigma   = " << event_sigma << "\n\n";
        std::cout << "A, B and SIGMA were overriden by EVENT_A_B_SIGMA environment variable!\n\n";
        // Se a variável de ambiente "EVENT_A_B_SIGMA" estiver definida, ela sobrescreve os valores de event_a, event_b e event_sigma.
        // Exibe os valores antigos e novos no console.
    } else {
        if (controllerPresetSelected) {
            std::cout << "Setting values from " << controllerArgParameter << " preset for a, b and sigma!\n";
            // Caso contrário, define os valores de a, b e sigma a partir do preset do controlador selecionado.
        }
    }

    ss.str("");
    // Limpa a stringstream.

    if(const char* env_k = std::getenv("SYS_DLQR_K")) {
        std::cout << "OVERRIDING K controller gains with values from environment variable SYS_DLQR_K\n"
                    << "Original values:\n"
                    << "K[0,0]  = " << sys_dlqr_K[0] << "\n"
                    << "K[0,1]  = " << sys_dlqr_K[1] << "\n\n";
        ss = std::stringstream{env_k};
        ss >> sys_dlqr_K[0];
        ss >> sys_dlqr_K[1];
        std::cout << "NEW values:\n"
                    << "K[0,0]  = " << sys_dlqr_K[0] << "\n"
                    << "K[0,1]  = " << sys_dlqr_K[1] << "\n\n";
        std::cout << "K controller was overriden by SYS_DLQR_K environment variable!\n\n";
        // Se a variável de ambiente "SYS_DLQR_K" estiver definida, sobrescreve os valores da matriz de ganhos K.
        // Exibe os valores antigos e novos no console.
    } else {
        if (controllerPresetSelected) {
            std::cout << "Setting default values for K!\n";
            // Se não houver variável de ambiente "SYS_DLQR_K", define os valores padrão para a matriz de ganhos K.
        }
    }
}

// Exibe as matrizes A, B e K
sys_matrix_A.print("matrix A");
sys_matrix_B.print("matrix B");
sys_dlqr_K.print("dLQR controller matrix K");

// Calcula a norma da multiplicação da matriz B pela matriz K e exibe o valor
matrix_norm = arma::norm(sys_matrix_B*sys_dlqr_K, 2);
std::cout << "norm of B*K: " << matrix_norm << "\n\n";

// Exibe o tipo de referência de controle
std::cout << "control type: " << referenceType << "\n\n";

// Exibe os parâmetros do evento
std::cout << "Event parameters:\n"
          << "      a = " << event_a     << "\n"
          << "      b = " << event_b     << "\n"
          << "  sigma = " << event_sigma << "\n\n";

// Instancia a classe 'ManoplaLelyBBB' com o nome da interface CAN
manopla::ManoplaLelyBBB manopla{can_interface_name};
int dummy_counter = 0;
int linear_position = 0;
// Registra o tempo inicial em microssegundos
auto initial_time= std::chrono::duration_cast<std::chrono::microseconds>(Clock::now().time_since_epoch()).count();

// Cria um objeto para armazenar os logs, com as colunas definidas
MyLog log{{"time_us", "pulse_qc", "setpoint_current_mA", "actual_current_mA", "epos_velocity_unfiltered_rpm", "calculated_velocity_rad/s", "tracked_reference", "event_max_error", "event_error"}};

// Definição de callback para sincronização no modo de posição
manopla::SyncCallback onSyncCallbackPositionMode = [&](const manopla::Time& t, const manopla::MotorInfo& mi, manopla::MyDriver& driver){
    using std::setw;
    using std::setprecision;
    using std::chrono::duration_cast;
    using std::chrono::microseconds;

    // Mantém a voltagem ativa
    driver.tpdo_mapped[0x6040][0] = static_cast<uint16_t>(0x02);

    // Exibe o tempo acumulado e o número atual de pulsos após 500ms
    if (t.current_dt_us > duration_cast<microseconds>(500ms).count()) {
        std::cout << setw(20) << t.sum_total_dt << setw(20) << t.current_dt_us << setw(20) << mi.currentPulses << '\n';
    }

    // Define os parâmetros da função senoide
    auto omega = (8*2*M_PIf32);
    auto phi = 0;
    auto time = t.current_us - initial_time;
    auto A = 500;

    // Calcula a posição baseada na função seno
    auto sine_position = A*std::sin(static_cast<double>(time)*omega+phi);

    // Atualiza a posição de acordo com a função seno
    driver.tpdo_mapped[0x2062][0] = static_cast<int32_t>(sine_position);

    // Exibe o valor da senoide após 100ms
    if (time > duration_cast<microseconds>(100ms).count()) {
        std::cout << "sine: " << setw(20) << time << setw(20) << sine_position << "\n";
    }
};

// Definição de variáveis para impressão periódica
uint64_t good_print_period_ms = 300;
uint64_t dt_sum_for_printing_ms = 0;

// Definição de callback para sincronização no modo de corrente
manopla::SyncCallback onSyncCallbackCurrentMode = [&](const manopla::Time& t, const manopla::MotorInfo& mi, manopla::MyDriver& driver) {
    using std::setw;
    using std::setprecision;
    using std::chrono::duration_cast;
    using std::chrono::microseconds;
    using namespace std::chrono_literals;

    // Mantém a voltagem ativa
    driver.tpdo_mapped[0x6040][0] = static_cast<uint16_t>(0x02);

    // Define os parâmetros da função senoide
    auto omega = (2*M_PIf32);
    auto phi = 0;
    auto time_us = t.current_us - initial_time;
    auto time_s = static_cast<double>(time_us)/1000000.f;
    auto A = 400;

    // Calcula a corrente setpoint baseada na função seno
    auto sine_current_setpoint = A * std::sin(time_s * omega + phi);

    // Atualiza o setpoint de corrente baseado na função seno
    driver.tpdo_mapped[0x2030][0] = static_cast<int16_t>(sine_current_setpoint);

    // Calcula a velocidade com base no ângulo atual e anterior
    float calculated_speed = (mi.currentAngle - mi.prevAngle)/(static_cast<float>(t.current_dt_us) / 1000000.f);
    dt_sum_for_printing_ms += t.current_dt_us;

    // Exibe os valores após um período definido
    if (dt_sum_for_printing_ms > good_print_period_ms) {
        std::cout << "t.current_us: " << setw(10) << t.current_us
                  << " time_us: " << setw(10) << time_s
                  << " calculated_speed: " << setw(10) << calculated_speed
                  << " currentAngle:" << setw(10) << mi.currentAngle
                  << " prevAngle:" << setw(10) << mi.prevAngle << '\n';
        dt_sum_for_printing_ms = 0ull;
    }

    // Se o driver estiver pronto, registra os dados no log
    if(driver.IsReady()) {
        log.addDataPoint(DataPoint{time_us, mi.currentPulses, sine_current_setpoint, mi.currentCurrent, mi.currentRotationUnfiltered, calculated_speed, 0, 0, 0});
    }
};

// Definição das variáveis usadas no controle PID
float referencePosition = 0.f;
float referenceVelocity = 0.f;
float errorPosition = 0.f;
float errorPositionSum = 0.f;
float errorVelocity = 0.f;
float controlActionP = 0.f;
float controlActionI = 0.f;
float controlActionD = 0.f;
float controlSignal = 0.f;
float calculatedSpeed = 0.f;

// Definição de callback para sincronização no modo PID
manopla::SyncCallback onSyncCallbackPID = [&](const manopla::Time& t, const manopla::MotorInfo& mi, manopla::MyDriver& driver) {
    using std::setw;
    using std::setprecision;
    using std::chrono::duration_cast;
    using std::chrono::microseconds;
    using namespace std::chrono_literals;

    // Mantém a voltagem ativa
    driver.tpdo_mapped[0x6040][0] = static_cast<uint16_t>(0x02);

    // Calcula a velocidade
    auto time_us = t.current_us - initial_time;
    auto time_s = static_cast<double>(time_us)/1000000.f;
    calculatedSpeed = (mi.currentAngle - mi.prevAngle)/(static_cast<float>(t.current_dt_us) / 1000000.f);

    // Calcula o erro de posição e velocidade
    errorPosition = referencePosition - mi.currentAngle;
    errorVelocity = referenceVelocity - calculatedSpeed;

    // Acumula o erro de posição
    errorPositionSum += errorPosition * t.current_dt_us / 1000000.f;

    // Calcula as ações de controle proporcional, derivativa e integral
    controlActionP = kp * errorPosition;
    controlActionD = kd * errorVelocity;
    controlActionI = ki * errorPositionSum;

    // Soma as ações de controle para determinar o sinal de controle final
    controlSignal = controlActionP + controlActionD + controlActionI;

    // Atualiza o sinal de controle no driver
    driver.tpdo_mapped[0x2030][0] = static_cast<int16_t>(controlSignal);

    // Se o driver estiver pronto, registra os dados no log
    if(driver.IsReady()) {
        log.addDataPoint(DataPoint{time_us, mi.currentPulses, controlSignal, mi.currentCurrent, mi.currentRotationUnfiltered, calculatedSpeed, 0, 0, 0});
    }
};

arma::colvec x{0, 0};
// Inicializa um vetor coluna 'x' com dois elementos, ambos com valor 0. Esse vetor representa o estado do sistema.

arma::mat controlInput;
// Declara uma matriz 'controlInput', que será usada para armazenar os sinais de controle calculados.

arma::colvec error_ref{x};
// Inicializa um vetor coluna 'error_ref' com o valor de 'x'. Esse vetor armazenará o erro de referência.

arma::colvec x_ref{x};
// Inicializa um vetor coluna 'x_ref' com o valor de 'x'. Esse vetor armazenará a referência do estado.

auto reference = [&](double time_s)->double{return 400*std::cos(2*M_PI*time_s);};
// Declara uma função lambda 'reference' que calcula uma referência senoidal de amplitude 400 e frequência
// baseada no tempo 'time_s'. Será usada para gerar uma referência de entrada para o controle.

double max_error{0};
// Inicializa a variável 'max_error' com valor 0. Ela armazenará o erro máximo permitido durante o controle.

double error{0};
// Inicializa a variável 'error' com valor 0. Ela armazenará o erro atual entre o estado e a referência.

manopla::SyncCallback onSyncCallbackDLQR = [&](const manopla::Time& t, const manopla::MotorInfo& mi, manopla::MyDriver& driver) {
// Declara um callback 'onSyncCallbackDLQR' que é chamado a cada ciclo de sincronização, com as informações de tempo, 
// informações do motor e o driver do motor.

    using std::setw;
    using std::setprecision;
    using std::chrono::duration_cast;
    using std::chrono::microseconds;
    using namespace std::chrono_literals;
    // Importa funções e namespaces para formatar a saída e lidar com manipulação de tempo.

    driver.tpdo_mapped[0x6040][0] = static_cast<uint16_t>(0x02);
    // Mantém a tensão ligada no motor enviando um comando de controle (0x02) para a entrada mapeada no índice 0x6040.

    auto time_us = t.current_us - initial_time;
    // Calcula o tempo em microssegundos desde o início do processo subtraindo o tempo atual do tempo inicial.

    auto time_s = static_cast<double>(time_us)/1000000.f;
    // Converte o tempo em microssegundos para segundos.

    calculatedSpeed = (mi.currentAngle - mi.prevAngle)/(static_cast<float>(t.current_dt_us) / 1000000.f);
    // Calcula a velocidade atual do motor com base na diferença de ângulo entre o ciclo atual e o anterior, 
    // dividida pelo tempo decorrido entre os ciclos.

    x.at(0) = mi.currentPulses;
    // Atualiza o primeiro elemento de 'x' com os pulsos atuais do motor, que representam a posição.

    x.at(1) = calculatedSpeed;
    // Atualiza o segundo elemento de 'x' com a velocidade calculada do motor.

    if (referenceType == ReferenceType::SineWave) {
        x_ref = {reference(time_s), 0};
        // Se o tipo de referência for uma onda senoidal, define 'x_ref' como a posição da onda senoidal no tempo atual e 0 para a velocidade.

        error_ref = - (x_ref - x);
        // Calcula o erro de referência como a diferença entre 'x_ref' e 'x', invertido.
    }

    if (referenceType == ReferenceType::ConstantZero) {
        controlInput = (sys_dlqr_K * x);
        // Se o tipo de referência for uma constante zero, calcula o sinal de controle multiplicando a matriz de ganhos DLQR 'sys_dlqr_K' pelo estado 'x'.
    } else if (referenceType == ReferenceType::SineWave) {
        controlInput = (sys_dlqr_K * error_ref);
        // Se o tipo de referência for uma onda senoidal, calcula o sinal de controle multiplicando a matriz de ganhos pelo erro de referência 'error_ref'.
    }

    controlSignal = controlInput.at(0);
    // Define o sinal de controle como o primeiro valor de 'controlInput'.

    driver.tpdo_mapped[0x2030][0] = static_cast<int16_t>(controlSignal);
    // Envia o sinal de controle para o driver do motor, mapeado no índice 0x2030.

    dt_sum_for_printing_ms += t.current_dt_us/1000.f;
    // Acumula o tempo decorrido desde a última impressão em milissegundos.

    if (dt_sum_for_printing_ms > good_print_period_ms) {
        std::cout << "t.current_us: " << setw(10) << t.current_us
                  << " currentAngle:" << setw(10) << mi.currentAngle
                  << " controlInput: " << setw(10) << controlInput.at(0)
                  << '\n';
        // Se o tempo acumulado exceder o período de impressão, exibe o tempo atual, o ângulo atual do motor e o sinal de controle.
        dt_sum_for_printing_ms = 0ull;
        // Reseta o acumulador de tempo após a impressão.
    }

    if(driver.IsReady()) {
        DataPoint a;
        if (referenceType == ReferenceType::ConstantZero) {
            log.addDataPoint(DataPoint{time_us, mi.currentPulses, controlSignal, mi.currentCurrent,
                                       mi.currentRotationUnfiltered, calculatedSpeed, 0, 0, 0});
            // Se o driver estiver pronto e a referência for zero constante, adiciona um ponto de dados ao log com os valores atuais do motor.
        } else if (referenceType == ReferenceType::SineWave) {
            log.addDataPoint(DataPoint{time_us, mi.currentPulses, controlSignal, mi.currentCurrent,
                                       mi.currentRotationUnfiltered, calculatedSpeed, x_ref.at(0), 0, error_ref.at(0)});
            // Se a referência for uma onda senoidal, adiciona um ponto de dados ao log, incluindo a referência de posição e o erro.
        }
    }
};
// Fim da definição do callback 'onSyncCallbackDLQR'.

// Este bloco está comentado, parando o manopla (controlador) após 3 milhões de microssegundos (~3 segundos).
/*if (time_us > 3e6) {
    manopla.stop();
}*/
};

// Inicializa o vetor `x` com valores 0 (posição e velocidade).
x = {0, 0};

// Cria uma cópia de checkpoint do estado `x`.
arma::colvec x_checkpoint{x};

// Inicializa a variável de energia (ou erro acumulado) `E` como 0.
double E{0};

// Variáveis contadoras para o número de atualizações e o tempo total.
uint refresh_count{0};
uint time_count{0};

// Vetor para armazenar os timestamps de quando as atualizações ocorrem.
std::vector<uint64_t> vec_refreshed{};

// Inicializa `controlInput` com uma matriz zero de tamanho 1x2 multiplicada por uma matriz 2x1.
controlInput = arma::zeros(1,2) * arma::zeros(2,1);

// Define um callback `onSyncCallbackDLQREvent` que será chamado durante a sincronização do motor.
// Utiliza várias bibliotecas padrão para formatação e conversão de tempo.
manopla::SyncCallback onSyncCallbackDLQREvent = [&](const manopla::Time& t, const manopla::MotorInfo& mi, manopla::MyDriver& driver) {
    using std::setw;
    using std::setprecision;
    using std::chrono::duration_cast;
    using std::chrono::microseconds;
    using namespace std::chrono_literals;

    // Mantém a tensão no motor ativada (modo de operação específico).
    driver.tpdo_mapped[0x6040][0] = static_cast<uint16_t>(0x02);

    // Calcula o tempo decorrido em microssegundos e segundos.
    auto time_us = t.current_us - initial_time;
    auto time_s = static_cast<double>(time_us)/1000000.f;

    // Calcula a velocidade com base na variação do ângulo do motor em relação ao tempo.
    calculatedSpeed = (mi.currentAngle - mi.prevAngle)/(static_cast<float>(t.current_dt_us) / 1000000.f);

    // Atualiza o vetor `x` com os pulsos atuais e a velocidade calculada.
    x.at(0) = mi.currentPulses;
    x.at(1) = calculatedSpeed;

    // Se o tipo de referência for uma onda senoidal, calcula a referência de posição e o erro de controle.
    if (referenceType == ReferenceType::SineWave) {
        x_ref = {reference(time_s), 0};
        error_ref = - (x_ref - x);
    }

    // Verifica se a referência é uma constante e calcula o erro máximo permitido usando a função `super_event`.
    if (referenceType == ReferenceType::ConstantZero) {
        max_error = super_event(arma::norm(x, 2), matrix_norm, time_s, event_a, event_b, event_sigma);
    } else {
        max_error = super_event(arma::norm(error_ref, 2), matrix_norm, time_s, event_a, event_b, event_sigma);
    }

    // Verifica se o erro atual excede o erro máximo permitido.
    if (error > max_error) {
        // Se o tipo de referência for constante, atualiza o controle usando `x`.
        if (referenceType == ReferenceType::ConstantZero) {
            controlInput = (sys_dlqr_K * x);
            x_checkpoint = x;
        } else if (referenceType == ReferenceType::SineWave) {
            controlInput = (sys_dlqr_K * error_ref);
            x_checkpoint = error_ref;
        }
        refresh_count++; // Incrementa o contador de atualizações.
        vec_refreshed.push_back(time_us); // Armazena o timestamp da atualização.
    }
    time_count++; // Incrementa o contador de tempo.

    // Sinal de controle calculado.
    controlSignal = controlInput.at(0);

    // Atualiza o erro com base na diferença entre o checkpoint e o estado atual.
    if (referenceType == ReferenceType::ConstantZero) {
        error = arma::norm(x_checkpoint - x, 2);
    } else if (referenceType == ReferenceType::SineWave) {
        error = arma::norm(x_checkpoint - error_ref, 2);
    }

    // Mapeia o sinal de controle para o driver.
    driver.tpdo_mapped[0x2030][0] = static_cast<int16_t>(controlSignal);

    // Acumula o tempo decorrido para impressão periódica.
    dt_sum_for_printing_ms += t.current_dt_us/1000.f;

    // Se o período de impressão for excedido, imprime os valores calculados.
    if (dt_sum_for_printing_ms > good_print_period_ms) {
        std::cout << "t.current_us: " << setw(10) << t.current_us
                  << " time_s: " << setw(10) << setprecision(2) << time_s
                  << " calculatedSpeed: " << setw(10) << calculatedSpeed
                  << " currentAngle:" << setw(10) << mi.currentAngle
                  << " currentPulses:" << setw(10) << mi.currentPulses
                  << " prevAngle:" << setw(10) << mi.prevAngle
                  << " error:" << setw(10) << error
                  << " max_error:" << setw(10) << max_error
                  << " controlInput: " << setw(10) << controlInput.at(0) << "(" << controlInput.n_rows << "," << controlInput.n_cols << ")"
                  << " x_ref: " << setw(10) << x_ref << "\n";

        // Reseta o acumulador de tempo para a próxima impressão.
        dt_sum_for_printing_ms = 0ull;
    }

    // Se o driver estiver pronto, adiciona um ponto de dados ao log.
    if(driver.IsReady()) {
        DataPoint a;
        if (referenceType == ReferenceType::ConstantZero) {
            log.addDataPoint(DataPoint{time_us, mi.currentPulses, controlSignal, mi.currentCurrent,
                                       mi.currentRotationUnfiltered, calculatedSpeed, 0, max_error, error});
        } else if (referenceType == ReferenceType::SineWave) {
            log.addDataPoint(DataPoint{time_us, mi.currentPulses, controlSignal, mi.currentCurrent,
                                       mi.currentRotationUnfiltered, calculatedSpeed, x_ref.at(0), max_error, error});
        }
    }

    // O código comentado abaixo para parar o controlador manopla após 3 segundos.
/*if (time_us > 3e6) {
    manopla.stop();
}*/
};

// Prepara o controlador "manopla" para operar em modo de corrente com os arquivos de configuração adequados.
manopla.prepare(250000, "master-dcf-motorzao-current-5000.dcf", "master-dcf-motorzao-current-5000.bin", manopla::MotionMode::CurrentMode);

// Limpa a stringstream `ss` para reutilização.
ss.str("");

// Instala o callback de sincronização correto com base no valor de `synccallback`.
if (synccallback == "position-mode") {
    manopla.installOnSyncCallback(onSyncCallbackPositionMode);
}
else if (synccallback == "current-mode") {
    manopla.installOnSyncCallback(onSyncCallbackCurrentMode);
}
else if (synccallback == "pid") {
    manopla.installOnSyncCallback(onSyncCallbackPID);
}
else if (synccallback == "dlqr") {
    manopla.installOnSyncCallback(onSyncCallbackDLQR);
}
else if (synccallback == "dlqr-event") {
    manopla.installOnSyncCallback(onSyncCallbackDLQREvent);
}

// Constrói o nome do arquivo CSV onde os dados serão salvos, baseado nos parâmetros de controle.
ss << synccallback << "_" << controllerArgParameter << ".csv";

// Inicia o loop de controle do manopla.
manopla.start_loop();

// Calcula a taxa de atualização com base no número de atualizações e no tempo total.
float refresh_rate{};
if(synccallback == "dlqr-event") {
    refresh_rate = (100.f * refresh_count) / (1.f * time_count);
} else {
    refresh_rate = 100.f;
}

// Imprime a taxa de atualização no console.
std::cout << "\n\n" << "REFRESH RATE: " << refresh_rate << " (" << refresh_count << " / " << time_count << ")\n\n";

// Salva os dados de log no arquivo CSV.
log.saveToFile(ss.str(), synccallback, referenceType, sys_matrix_A, sys_matrix_B, sys_dlqr_K, event_a, event_b, event_sigma, refresh_rate);

// Retorna 0 para indicar que o programa terminou com sucesso.
return 0;

